#!/bin/sh

##
## NO T OPTION FOR RSYNC

# globals
syncdir=".zsync"
timestamp_file=".zsync/timestamp"
lock_file=".zsync/lock"
tree_file=".zsync/tree"
server_file=".zsync/server"

rsync_opts='-rvlpE'

# usage
fname=$(basename "$0")
usage()
{
  echo "$fname [operation]

Operations:
  server <server>     Setup sync on current folder with server target
  run [file...]       Run sync with server
  push [file...]      Regular run but push all conflicts
  pull [file...]      Regular run but pull all conflicts
  dry [file...]       Run a simulated sync but do not perform any action
  drypush [file...]   Dry run as push
  drypull [file...]   Dry run as pull
  forcepush           Push by force the entire tree. Will replace and delete remote files
  forcepull           Pull by force the entire tree. Will replace and delete local files"
}

# generic tools

# read list from stdin
reduce_list()
{
  list="$(cat /dev/stdin)"
  I=1
  while true
  do
    ln=$(echo "$list" | sed -n "$I"p) # get nth line
    [ -z "$ln" ] && break
    list=$(echo "$list" | grep -v "^$ln/")
    I=$((I+1))
  done
  echo "$list"
}


lock_local() { touch "$lock_file"; }
unlock_local() { rm "$lock_file"; }
lock_server() { ssh "$raddr" "cd '$rdir' && touch '$lock_file'"; }
unlock_server() { ssh "$raddr" "cd '$rdir' && rm '$lock_file'"; }
lock_all() { lock_local && lock_server ; }
unlock_all() { ret=0; unlock_local || ret=$? ; unlock_server || ret=$?; return $ret ; }

local_lock_check() {
  [ ! -f "$lock_file" ] || { echo "Local sync locked, wait for sync completion" >&2 && return 1; }
}
server_lock_check() {
  ssh "$raddr" "cd '$rdir' && [ ! -f '$lock_file' ]" || { echo "Server is busy, wait for sync completion" >&2 && return 1; }
}

set_timestamp_local() { date +%s > "$timestamp_file" ; }

# $@ = match these
merge()
{
  if [ $# -gt 0 ]
  then
    re="^\./$1"
    shift 1
    for N
    do
      re="$re|^\./$N"
    done
    grep -E "($re)"
  else # don't change input
    cat
  fi
  return 0
}

get_newer_local_files()
{
  TIME=$(cat "$timestamp_file" 2>/dev/null)
  if [ "$TIME" -gt 0 ] 2>/dev/null
  then
    find . ! -type d ! -regex "^./$syncdir/.*" -newermt @$TIME | merge "$@"
  else
    find . ! -type d ! -regex "^./$syncdir/.*" | merge "$@"
  fi
}
get_newer_server_files()
{
  TIME=$(cat "$timestamp_file" 2>/dev/null)
  if [ "$TIME" -ge 0 ] 2>/dev/null
  then
    ssh $raddr "cd '$rdir' && find . ! -type d ! -regex '^\./$syncdir/.*' -newermt @$TIME" | merge "$@"
  else
    ssh $raddr "cd '$rdir' && find . ! -type d ! -regex '^\./$syncdir/.*'" | merge "$@"
  fi
}

# full list
get_server_list() {
  ssh $raddr "cd '$rdir' || exit 1
  find . ! -regex '^\./$syncdir.*'" | sort | merge "$@"
}
get_local_list() {
  find . ! -regex "^\./$syncdir.*" | sort | merge "$@"
}

get_server_composed_list()
{
  TIME=$(cat "$timestamp_file" 2>/dev/null)
  [ "$TIME" -ge 0 ] 2>/dev/null || TIME=0
  { ssh $raddr "cd '$rdir' || exit 1
  {
    find . ! -regex '^\./$syncdir.*'
    find . ! -type d ! -regex '^\./$syncdir/.*' -newermt @$TIME
  } | sort" ||  return $? ; } | merge "$@"
}

# find deleted from list
# $1 = full list , $@ = merge
get_deleted()
{
  [ ! -f "$tree_file" ] && return 0
  arg=$1
  shift 1
  echo "$arg" | diff --new-line-format="" --unchanged-line-format="" "$tree_file" - | reduce_list | merge "$@"
}

# init
init_local() {
  mkdir -p "$syncdir" || exit $?
}
init_server() {
  ssh $raddr "mkdir -p '$rdir/$syncdir' && { which rsync >/dev/null 2>&1 || { echo \"rsync not found on server\" >&2 && exit 1; } ; }" || return $?
  # ssh $raddr "which rsync >/dev/null 2>&1" || { echo "rsync not found on server" >&2 && return 1; }
}

initandcheck_server() {
  ssh $raddr "mkdir -p '$rdir/$syncdir' && cd '$rdir' {
    which rsync >/dev/null 2>&1 || { echo \"rsync not found on server\" >&2 ; exit 1; } ;
  } && {
    [ ! -f '$lock_file' ] || { echo \"Server is busy, wait for sync completion\" ; exit 1; }
  } && exit 0" || return $?
  # ssh $raddr "which rsync >/dev/null 2>&1" || { echo "rsync not found on server" >&2 && return 1; }
}
full_prep_server() {
  ssh $raddr "
    mkdir -p '$rdir/$syncdir' || exit 1
    cd '$rdir' || exit 2
    which rsync >/dev/null 2>&1 || { echo rsync not installed on server >&2 ; exit 3; }
    [ -f '$lock_file' ] && { echo Server is busy, wait for sync completion ; exit 4; }
    touch '$lock_file' || exit 5
    exit 0"
  # ssh $raddr "which rsync >/dev/null 2>&1" || { echo "rsync not found on server" >&2 && return 1; }
}

# read file list from stdin
# $1 = list of files
send() {
  if [ "$1" = "dry" ]
  then
    echo "* files to send"
    sed 's|\./||g'
  else
    printf '* '
    rsync $rsync_opts --files-from=- --exclude=".zsync" -e ssh "$(pwd)" "$raddr:$rdir" || return $?
  fi
}

# read file list from stdin
recieve() {
  if [ "$1" = "dry" ]
  then
    echo "* files to recieve"
    sed 's|\./||g'
  else
    printf '* '
    rsync $rsync_opts --files-from=- -e ssh "$raddr:$rdir" "$(pwd)" || return $?
  fi
}


# read delete from stdin
delete_server() {
  if [ "$1" = "dry" ]
  then
    echo "* deleted to send"
    sed 's|\./||g'
  else
    echo "* sending deleted"
    ssh $raddr "cd '$rdir' || exit 1
    trashutil='gio trash'
    which trash-put >/dev/null 2>&1 && trashutil=trash-put
    while read -r ln
    do
      \$trashutil \"\$ln\" && echo \"\$ln\" || exit \$?
    done
    " || return $?
  fi
}
# read delete from stdin
delete_local() {
  if [ "$1" = "dry" ]
  then
    echo "* deleted to recieve"
    sed 's|\./||g'
  else
    echo "* recieving deleted"
    trashutil='gio trash'
    which trash-put >/dev/null 2>&1 && trashutil=trash-put
    while read -r ln
    do
      $trashutil "$ln" && echo "$ln" || return $?
    done
  fi
}

get_server() {
  [ ! -f "$server_file" ] && return 1
  raddr=$(cut -d ':' -f1 "$server_file")
  rdir=$(cut -d ':' -f2- "$server_file")
}

setup_server()
{
  init_local || return $?
  [ -z "$1" ] && echo "$fname server user@host:path" && return 1
  echo "$1" > "$server_file"
}

forcepull()
{
  rsync $rsync_opts -r --delete -e ssh "$raddr:$rdir" "$(pwd)/." || return $?
  sleep 1
  set_timestamp_local
}

forcepush()
{
  rsync $rsync_opts -r --delete -e ssh "$(pwd)/." "$raddr:$rdir" || return $?
  sleep 1
  set_timestamp_local
}

# $1 = method (null/'push'/'pull') , $2 = dry (null/'dry') , $@ = files
sync()
{
  method=$1
  dry=$2
  shift 2

  get_server  || { echo "Server not configured on this instance" >&2 && return 1; }

  # init and check local
  init_local  || return $?
  local_lock_check || return $?

  # init, check, and lock server
  full_prep_server || {
    case $? in
      5) ret=$? ; unlock_server ; return $ret ;;
      *) return $? ;;
    esac
  }

  # lock
  lock_local || { unlock_all ; return 1; }

  # retrieve local lists
  local_list=$(get_local_list "$@") || { unlock_all ; return 1; }
  local_newer=$(get_newer_local_files "$@") || { unlock_all ; return 1; }

  # retrieve server lists
  server_composed_list=$(get_server_composed_list "$@") || { unlock_all; return 1; }
  server_list=$(echo "$server_composed_list" | uniq)
  server_newer=$(echo "$server_composed_list" | uniq -d)


  # get collisions
  collisions=$(printf "%s\n%s" "$local_newer" "$server_newer" | sort | uniq -d)
  [ -n "$collisions" ] && [ "$method" != "push" ] && [ "$method" != pull ] && {
    echo "-- There are file collisions" >&2
    echo "$collisions" | sed 's|^\./||g'
    unlock_all
    return 100
  }


  # remove collisions from opposing method
  [ -n "$collisions" ] && {
    if [ "$method" = "pull" ]
    then
      local_newer=$(printf "%s\n%s\n" "$collisions" "$local_newer" | sort | uniq -u)
    else
      server_newer=$(printf "%s\n%s\n" "$collisions" "$server_newer" | sort | uniq -u)
    fi
  }

  # get deleted on both sides
  deleted_local=$(get_deleted "$local_list" "$@") || { unlock_all ; return 1; }
  deleted_server=$(get_deleted "$server_list" "$@") || { unlock_all ; return 1; }

  if [ -n "$local_newer" ] || [ -n "$server_newer" ] || [ -n "$deleted_local" ] || [ -n "$deleted_server" ]
  then
    # operations
    if [ "$method" = "pull" ]
    then
      [ -n "$server_newer" ] && echo "$server_newer" | recieve "$dry" | sed 's|^\./||g'
      [ -n "$local_newer"  ] && echo "$local_newer"  | send    "$dry" | sed 's|^\./||g'
    else
      [ -n "$local_newer"  ] && echo "$local_newer"  | send    "$dry" | sed 's|^\./||g'
      [ -n "$server_newer" ] && echo "$server_newer" | recieve "$dry" | sed 's|^\./||g'
    fi
    # wait 1s to make sure, for timestamp
    sleep 1 &

    # delete has no impact on timestamps
    [ -n "$deleted_local"  ] && echo "$deleted_local"  | delete_server "$dry" | sed 's|^\./||g'
    [ -n "$deleted_server" ] && echo "$deleted_server" | delete_local  "$dry" | sed 's|^\./||g'

    # real run
    [ "$dry" != "dry" ] && {
      # update tree
      get_local_list > "$tree_file"
      wait
      # set timestamp
      set_timestamp_local
    }
  fi
  unlock_all
}

which rsync >/dev/null || { echo "rsync not installed" >&2 && exit 1; }

# options
unset arg_c
while getopts ":hC:" opt;
do
  case $opt in
    C)
      [ -z "$OPTARG" ] && echo "Option -C requires an argument" >&2 && exit 1
      arg_c="$OPTARG"
      ;;
    h) usage && exit 1 ;;
    \?) echo "Uknown option: $OPTARG" >&2 && usage && exit 1 ;;
  esac
done
shift $((OPTIND-1))

# raddr=zawz@zawz.net
# rdir=sync/tmp
[ -f "$server_file" ] && get_server

# preprocess
[ -n "$arg_c" ] && { cd "$arg_c" || exit $?; }   # -C opt

[ $# -lt 1 ] && usage && exit 1
arg=$1
shift 1

# actions
case $arg in
  server) setup_server "$@" ;;
  run)     sync ""   ""  "$@" ;;
  pull)    sync pull ""  "$@" ;;
  push)    sync push ""  "$@" ;;
  dry)     sync ""   dry "$@" ;;
  drypush) sync push dry "$@" ;;
  drypull) sync pull dry "$@" ;;
  forcepush) forcepush ;;
  forcepull) forcepull ;;
  *) usage && exit 1 ;;
esac
